package com.meggot.releasy.service

import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.google.common.collect.Lists
import com.google.common.collect.Maps
import com.meggot.releasy.model.dto.confluence.ConfluenceChildPage
import com.meggot.releasy.model.dto.confluence.ConfluenceContentResponse
import com.meggot.releasy.model.dto.confluence.ConfluenceJqlRequest
import com.meggot.releasy.model.dto.confluence.ConfluenceSearchResponse
import com.meggot.releasy.model.dto.jira.*
import com.meggot.releasy.model.dto.releasy.ProjectCode
import com.meggot.releasy.model.dto.releasy.ReleaseStatus
import com.meggot.releasy.model.dto.releasy.ReleaseStatusName
import com.meggot.releasy.model.dto.releasy.ReleaseTemplate
import com.meggot.releasy.service.validators.RestResponseValidator
import org.slf4j.LoggerFactory
import org.springframework.http.HttpEntity
import org.springframework.http.HttpMethod
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.stereotype.Service
import org.springframework.web.client.RestTemplate
import org.springframework.web.client.getForEntity

@Service
class JiraReleaseService(var confluenceRestTemplate: RestTemplate,
                         var restValidator: RestResponseValidator,
                         var objectMapper: ObjectMapper) {

    private val log = LoggerFactory.getLogger(this::class.java)

    private val jiraApi = "https://meggotdigital.atlassian.net/rest/api/2"

    private val baseJiraReleaseDescription = "This is a release generated by Releasy App"

    fun postJiraRelease(releaseTemplate: ReleaseTemplate): JiraReleaseResponse {
        val releaseBody = ReleaseBody(baseJiraReleaseDescription, releaseTemplate.releaseTitle, releaseTemplate.projectCode)

        log.info("Posting JIRA release {}", objectMapper.writeValueAsString(releaseBody))

        val response = confluenceRestTemplate.postForEntity("$jiraApi/version", releaseBody, JiraReleaseResponse::class.java)

        log.info("Jira Response: " + objectMapper.writeValueAsString(response))

        restValidator.validateJiraPostReleaseResponse(response)

        return response.body!!
    }

    fun attachReleaseToTickets(releaseTitle: String, serviceToTickets: Map<String, ArrayList<String>>) {
        serviceToTickets.entries.forEach { entry ->
            val service = entry.key
            entry.value.forEach { ticket ->
                log.info("Adding release ticket $ticket of service $service with fix version $releaseTitle")
                val updateTicketPostBody = UpdateComponentRequest(UpdateComponentRequest.UpdateBody(
                        fixVersions = Lists.newArrayList(UpdateComponentRequest.FixVersions(
                                Lists.newArrayList(UpdateComponentRequest.FixVersions.FixVersion(releaseTitle))))
                ))
                log.info("Sending post with body {}", objectMapper.writeValueAsString(updateTicketPostBody))
                val responseEntity = confluenceRestTemplate.exchange("$jiraApi/issue/$ticket", HttpMethod.PUT, HttpEntity(updateTicketPostBody), UpdateComponentResponse::class.java)
                log.info("Received response: {}", objectMapper.writeValueAsString(responseEntity))
                restValidator.validateUpdateComponentResponse(responseEntity)
            }
        }
    }

    fun getServicesAndTicketsMap(projectCode: String): HashMap<String, ArrayList<String>> {
        val jqlRequest = ConfluenceJqlRequest(
                "project = $projectCode AND status = 'Ready for Release'",
                "false",
                Lists.newArrayList("summary",
                        "status",
                        "assignee",
                        "operations",
                        "versionedRepresentations",
                        "editmeta",
                        "changelog",
                        "customfield_11700",
                        "renderedFields",
                        "components"),
                0)

        val response = confluenceRestTemplate.postForEntity("$jiraApi/search", jqlRequest, ConfluenceSearchResponse::class.java)
        log.debug("Releasy get services and tickets response: {} ", objectMapper.writeValueAsString(response))
        val serviceToTickets: HashMap<String, ArrayList<String>> = Maps.newHashMap()
        restValidator.validateConfluenceSearchResponse(response, projectCode)
        response.body!!.issues!!.forEach { issue ->
            issue.fields!!.components!!.forEach { component ->
                if (serviceToTickets.contains(component.name)) {
                    serviceToTickets[component.name]?.add(issue.key)
                } else {
                    serviceToTickets[component.name] = arrayListOf(issue.key)
                }
            }
        }
        return serviceToTickets
    }


    fun getUrlForJiraRelease(projectCode: String, releaseVersionId: String): String {
        return "https://meggotdigital.atlassian.net/projects/$projectCode/versions/$releaseVersionId/tab/release-report-all-issues"
    }

    fun isUserAdministratorOnProject(projectCode: String): Boolean {
        var status = confluenceRestTemplate.getForEntity("$jiraApi/project/$projectCode/roledetails", String::class.java)
        return status.statusCode != HttpStatus.UNAUTHORIZED
    }

}